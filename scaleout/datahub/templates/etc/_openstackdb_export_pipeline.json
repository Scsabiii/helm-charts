{
	"properties": {},
	"iconsrc": "",
	"description": "",
	"processes": {
		"s3consumer1": {
			"component": "com.sap.storage.s3.consumer",
			"metadata": {
				"label": "Swift-S3 Consumer",
				"x": 16,
				"y": 12,
				"height": 80,
				"width": 120,
				"subengines": [
					"main"
				],
				"config": {
					"aws_access_key_id": {{ $.Values.content.pipelines.openstackdb_import.key_id | quotes }},
					"aws_secret_access_key": {{ $.Values.content.pipelines.openstackdb_import.access_key | quotes }},
					"region": "i{{ $.Values.region }}",
					"endpointURL": "https://objectstore-3.{{ $.Values.region }}.cloud.sap:443",
					"bucket": "/datalake",
					"path": "/openstackdb_exports/cinder.volume_attachment.csv",
					"recursive": false,
					"pollPeriodInMs": 1000
				}
			},
			"securitycontexts": [
				""
			]
		},
		"wiretap1": {
			"component": "com.sap.util.wiretap",
			"metadata": {
				"label": "Wiretap",
				"x": 367.9999990463257,
				"y": 12,
				"height": 80,
				"width": 120,
				"ui": "dynpath",
				"config": {
					"spoolSize": 10000
				}
			}
		},
		"voraingestor1": {
			"component": "com.sap.vora.ingestor",
			"metadata": {
				"label": "Vora Ingestor",
				"x": 871.9999990463257,
				"y": 12,
				"height": 80,
				"width": 120,
				"subengines": [
					"main"
				],
				"config": {
					"dsn": "v2://vora-tx-coordinator:10002/?binary=true",
					"ingestionMode": "UPSERT",
					"user": "default\\ingestor",
					"password": "{{ $.Values.datahub.ingestor.password }}",
					"databaseSchema": "OPENSTACK",
					"primaryKeyRegex": "^id$",
					"aggregation": true
				}
			}
		},
		"golangoperator1": {
			"component": "com.sap.system.golangmengine2",
			"metadata": {
				"label": "Golang Operator",
				"x": 202,
				"y": 12,
				"height": 80,
				"width": 120,
				"extensible": true,
				"subengines": [
					"main"
				],
				"config": {
					"script": "package main\n\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"compress/gzip\"\n    \"encoding/json\"\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nvar Output func(interface{})\nvar re = regexp.MustCompile(\"(.*)\\\\.sql.gz\")\n\n// data chunks in the pg_backup file begin with this instruction\nvar pgbDataChunkPrefixRE = regexp.MustCompile(\"COPY public.(.*) \\\\((.*)\\\\) FROM stdin;\")\n\nvar pgbDataChunkSuffix = \"\\\\.\"\n\nfunc main() {\n\t// no special setup needed\n}\n\nfunc readTable(database string, r *bufio.Reader) (map[string]interface{}, string, error) {\n\t// skip lines until the prefix for data chunks is found\n\tline, incomplete, err := r.ReadLine()\n\tvar params []string = []string{}\n\tfor err == nil && !incomplete && len(params) != 3 {\n\t\tparams = pgbDataChunkPrefixRE.FindStringSubmatch(string(line))\n\t\tline, incomplete, err = r.ReadLine()\n\t}\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn nil, \"\", err\n\t}\n\n\t// build schema from column names relying on naming standards for OpenStack tables\n\t// IDEA: use earlier CREATE TABLE statements to build a more efficient schema\n\ttable := params[1]\n\tcolumns := strings.Split(params[2], \", \")\n\n\tfields := make([]map[string]interface{}, len(columns))\n    hasID := false\n\tfor i := range columns {\n\t\tif columns[i] == \"id\" {\n\t\t\tfields[i] = map[string]interface{}{\"name\": columns[i], \"type\": \"fixed\", \"size\": 127}\n            hasID = true\n\t\t} else {\n\t\t\t// treat all fields except id as nullable (union type in Avro)\n\t\t\tfields[i] = map[string]interface{}{\"name\": columns[i], \"type\": []string{\"string\", \"null\"}}\n\t\t}\n\t}\n\n    if !hasID {\n        fmt.Println(\"error: Table %s.%s lacks an 'id' field\", database, table)    \n\n        return nil, \"\", nil\n    }\n    \n\tschema := map[string]interface{}{\n\t\t\"namespace\": database,\n\t\t\"type\":      \"record\",\n\t\t\"name\":      table,\n\t\t\"fields\":    fields,\n\t}\n\n    fmt.Println(\"reading data for table %s ...\", table)\n    fmt.Println(\"Status: err %v, incomplete %b, last line %s\", err, incomplete, string(line))\n\t// read data line by line until the terminating suffix shows up\n\tpayload := \"\"\n\tfor err == nil && !incomplete && string(line) != pgbDataChunkSuffix {\n    \tfmt.Println(\"< \", string(line))\n\t\tvalues := strings.Split(string(line), \"\\t\")\n\t\tfor i := 0; i < len(values); i++ {\n\t\t    if values[i] == \"\\\\N\" {\n\t\t    \t// values[i] = \"\"\n\t\t    } else {\n\t\t        values[i] = strings.Replace(values[i], \"\\t\", \"    \", -1)\n\t\t    }\n\t\t}\n\t\tpayload += strings.Join(values, \"\\t\")\n\t\tpayload += \"\\n\"\n\t\tline, incomplete, err = r.ReadLine()\n\t}\n\n\treturn schema, payload, nil\n}\n\nfunc schemaFromCSV(database string, table string, csv []byte) string {\n    r := bufio.NewReaderSize(bytes.NewReader(csv), 1024)\n    line, _, _ := r.ReadLine()\n    columns := strings.Split(string(line), \",\")\n\n    fields := make([]map[string]interface{}, len(columns))\n    for i := range columns {\n        if columns[i] == \"id\" {\n            fields[i] = map[string]interface{}{\"name\": columns[i], \"type\": \"fixed\", \"size\": 127}\n        } else {\n            // treat all fields except id as nullable (union type in Avro)\n            fields[i] = map[string]interface{}{\"name\": columns[i], \"type\": []string{\"string\", \"null\"}}\n        }\n    }\n    schema := map[string]interface{}{\n        \"namespace\": database,\n        \"type\": \"record\",\n        \"name\": table,\n        \"fields\": fields,\n    }\n    \n    b, err := json.Marshal(schema)\n\tif err != nil {\n\t\tfmt.Println(\"error:\", err)\n\t    return \"\"\n\t}\n\treturn string(b)\n}\n\n// here implement the function with the input port name, so data coming from this input will call this function\nfunc Input(val interface{}){\n\tmessage := val.(map[string]interface{})\n\t\n\tfmt.Println(\"ccloud input arrived\")\n\t\n\t// read contents\n\tbody := message[\"Body\"]\n\tattr := message[\"Attributes\"].(map[string]interface{})\n\n\t// enhance header\n    filename_seg := re.FindStringSubmatch(attr[\"storage.filename\"].(string))\n\tif len(filename_seg) < 2 {\n\t    fmt.Println(\"ccloud: ERROR filename cannot be parsed\")\n\t    return\n\t}\n\t\n\tdatabase := filename_seg[1]\n\t\n\tgzr, _ := gzip.NewReader(bytes.NewReader(body.([]byte)))\n\tr := bufio.NewReaderSize(gzr, 8192)\n\tschema, payload, err := readTable(database, r)\n    for err == nil {\n        if payload != \"\" {\n            schemaStr, merr := json.Marshal(schema)\n            if merr != nil {\n    \t\t    fmt.Println(\"error:\", merr)\n    \t\t    return\n    \t    }\n    \n        \tnewAttr := make(map[string]interface{}, len(attr)+2)\n    \t    for key := range attr {\n    \t\t    newAttr[key] = attr[key]\n    \t    }\n            newAttr[\"vora.record.definition\"] = map[string]interface{}{\"recName\": schema[\"name\"]}\n            newAttr[\"avro.schema\"] = string(schemaStr)\n        \n            // build transformed message\n    \t    newMessage := make(map[string]interface{}, 3)\n    \t    newMessage[\"Attributes\"] = newAttr\n    \t    newMessage[\"Encoding\"] = message[\"Encoding\"]\n    \t    newMessage[\"Body\"] = payload\n    \n            // output\n            fmt.Println(\"ccloud output body: \", payload)\n    \t    Output(newMessage)\n        }\n       \n        // next next\n        schema, payload, err = readTable(database, r)\n    }\n    \n    fmt.Println(\"done\")\n}"
},
				"additionalinports": [
					{
						"name": "Input",
						"type": "message"
					}
				],
				"additionaloutports": [
					{
						"name": "Output",
						"type": "message"
					}
				]
			},
			"securitycontexts": [
				""
			]
		},
		"avropreingestor1": {
			"component": "com.sap.vora.preingestor",
			"metadata": {
				"label": "Avro PreIngestor",
				"x": 535.9999990463257,
				"y": 12,
				"height": 80,
				"width": 120,
				"config": {
					"format": "csv",
					"csvHeaderIncluded": true,
					"varLimit": 1024
				}
			}
		},
		"wiretap2": {
			"component": "com.sap.util.wiretap",
			"metadata": {
				"label": "Wiretap",
				"x": 711.9999990463257,
				"y": 12,
				"height": 80,
				"width": 120,
				"ui": "dynpath",
				"config": {
					"spoolSize": 10000
				}
			}
		}
	},
	"groups": [],
	"connections": [
		{
			"metadata": {
				"points": "140,61 198,61"
			},
			"src": {
				"port": "outFile",
				"process": "s3consumer1"
			},
			"tgt": {
				"port": "Input",
				"process": "golangoperator1"
			}
		},
		{
			"metadata": {
				"points": "326,61 345,61 345,52 363.9999990463257,52"
			},
			"src": {
				"port": "Output",
				"process": "golangoperator1"
			},
			"tgt": {
				"port": "in",
				"process": "wiretap1"
			}
		},
		{
			"metadata": {
				"points": "491.9999990463257,52 531.9999990463257,52"
			},
			"src": {
				"port": "out",
				"process": "wiretap1"
			},
			"tgt": {
				"port": "in",
				"process": "avropreingestor1"
			}
		},
		{
			"metadata": {
				"points": "659.9999990463257,52 707.9999990463257,52"
			},
			"src": {
				"port": "out",
				"process": "avropreingestor1"
			},
			"tgt": {
				"port": "in",
				"process": "wiretap2"
			}
		},
		{
			"metadata": {
				"points": "835.9999990463257,52 867.9999990463257,52"
			},
			"src": {
				"port": "out",
				"process": "wiretap2"
			},
			"tgt": {
				"port": "in",
				"process": "voraingestor1"
			}
		}
	],
	"inports": {},
	"outports": {}
}
